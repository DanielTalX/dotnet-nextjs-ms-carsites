npm config set registry https://registry.npmjs.org/

Sec02 - Creating the first microservice
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- goals:
    - Creating a simple API for the Auctions
    - CRUD
    - Seeding Data
    - Using Docker compose
    - Using Postman to test the API
- Creating the first micro service
    - create Carsties solution:
        - mkdir Carsties
        - cd Carsties
        - dotnet new sln
    - create a webapi project with dotnet v8:
        - cd Carsties
        - dotnet new webapi -o src/AuctionService --use-controllers
    - put thw webapi project inside the Carsties solution
        - cd Carsties
        - dotnet sln add src/AuctionService
- Reviewing and simplifying the project
    - in AuctionService.csproj:
        - set Nullable to disable
        - remain ImplicitUsings to enable
        - reamove all items in ItemGroup
    - in launchSettings.json:
        - remove iisSettings
        - remove https & IIS Express profiles
        - in http profile:
            - set launchBrowser to false
            - remove line "launchUrl": "swagger"
            - set "applicationUrl": "http://localhost:7001",
    - in appsettings.Development.json set  "Microsoft.AspNetCore": "Information"
    - Program.cs: remove anything that related to swagger
    - debuging the AuctionService:
        - cd src/AuctionService
        - dotnet watch
- Adding the entity classes
    - an entity represents a table inside a db
    - each of the entity properties represents a column inside that db
    - Auction, Item, Status
- Adding the Database context class
    - add Microsoft.EntityFrameworkCore.Design @Microsoft package to AuctionService from nuget gallery
    - add Npgsql.EntityFrameworkCore.PostgreSQL @Shay Rojansky,Austin Drenski,Yoh Deadfall package to AuctionService from nuget gallery
    - add AutoMapper.Extensions.Microsoft.DependencyInjection @Jimmy Bogard package to AuctionService from nuget gallery
    - add AuctionDbContext class
    - update program.cs to use the AuctionDbContext service and add it to the container
    - create db migration:
        - using dotnet-ef tool: to check if dotnet-ef tool installed globaly in the computer by: dotnet tool list -g
            if not, install it by: dotnet tool install dotnet-ef -g, or update it by: dotnet tool update dotnet-ef -g
        - execute the commands to create a new migration, which is going to take a look at our code and what we've written, 
            the Dbcontext class, and it's going to create a migration that will set up the database schema based on the code that we've written.
        - in AuctionService: dotnet ef migrations add "InitialCreate" -o Data/Migrations
- Adding a Postgres database server
    - install docker from https://docker.com & install docker vsc extension
    - inside the solution folder [Carsties] create docker-compose.yml file
    - [Carsties] run the docker compose file by: docker compose up -d
    - [AuctionService] run: dotnet ef database update
    - install PostgreSQL extension by Chris Kolkman & see the db
- Creating seed data
    - [AuctionService] to drop the db: dotnet ef database drop
    - run AuctionService & see the seed data
- Shaping the data to return
    - create DTOs folder
    - create RequestHelpers folder
    - update program.cs to use the AutoMapper service and add it to the container
- Adding an API controller
- Adding a postman collection
- Adding the create, update, delete auction endpoints


Sec03 - Creating a Search microservice
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- goals:
    - Creating a Search Service
    - Adding MongoDb
    - Sync communication between Services
- Creating the second micro services
    - [Carsties] dotnet new webapi -o src/SearchService --use-controllers
    - [Carsties] dotnet sln add src/SearchService
    - clean the project as earlier
    - add nuget packages from gallery:
        - MongoDB.Entities @Đĵ ΝιΓΞΗΛψΚ
        - AutoMapper.Extensions.Microsoft.DependencyInjection @Jimmy Bogard
    - [SearchService] verify everything is ok by: dotnet build
    - [SearchService] run by: dotnet watch
- Adding the MongoDb server
    - https://mongodb.com
    - [Carsties] update docker-compose.yml file to use mongodb image
    - [Carsties] run the docker compose file by: docker compose up -d
    - installMongoDB for VS Code extension
    - [SearchService] run: dotnet ef database update
- Adding the Item model
- Adding seed data
- Adding a search controller
    - https://mongodb-entities.com
- Paginating the results
- Adding filtering and ordering
- Synchronous messaging
- Adding Http communication to get the data
- Making our Http communication resilient
    - add nuget gallery: Microsoft.Extensions.Http.Polly @Microsoft


Sec04 - RabbitMQ
~~~~~~~~~~~~~~~~
- What is RabbitMQ
- Installing RabbitMQ
    - https://rabbitmq.com
    - http://localhost:15672
        - Username: guest
        - Password: guest
- Adding and configuring mass transit
    - https://masstransit.io
    - nuget gallery: MassTransit.RabbitMQ @Chris Patterson to both AuctionService & SearchService 
    - add shared lib for MassTransit:
        - [Carsties] dotnet new classlib -o src/Contracts
        - [Carsties] dotnet sln add src/Contracts
        - [Contracts.csproj] set Nullable to disable
    - add a reference to Contracts library from both the auction & search service
        - [AuctionService] dotnet add reference ../../src/Contracts
        - [SearchService] dotnet add reference ../../src/Contracts
- Adding the contracts
- Adding a consumer to consume a message from the Service bus
- Publishing the Auction Created event to the bus
- What could go wrong?
- Adding a message outbox
    - add nuget gallery to AuctionService: MassTransit.EntityFrameworkCore @Chris Patterson
    - override OnModelCreating in [AuctionDbContext.cs] file to support outbox
    - add a migration to support outbox:
        - dotnet ef migrations add Outbox
- Using message retries
- Consuming fault queues
- Challenge + Solution: Adding the update and delete consumers


Sec05 - Identity Server
~~~~~~~~~~~~~~~~~~~~~~~
- Introduction to Section 5
- 0Auth and OpenlDConnect
- Creating the Identity Server project
    - Duende - https://docs.duendesoftware.com/identityserver/v7/quickstarts/0_overview/
        - [Carsties] dotnet new install Duende.IdentityServer.Templates
    - [Carsties] dotnet new isaspid -o src/IdentityServer
        -> run seed? No
    - [Carsties] dotnet sln add src/IdentityServer
- Reviewing and configuring our new project
    - [IdentityServer] remove PackageReference - "Microsoft.EntityFrameworkCore.Sqlite" from [IdentityServer.csproj]
    - [IdentityServer] install gallery nuget package: Npgsql.EntityFrameworkCore.PostgreSQL @Shay Rojansky,Austin Drenski,Yoh Deadfall
    - [IdentityServer.Properties.launchSettings.json] - set applicationUrl to http://localhost:5000
    - [HostingExtensions.cs] updates
    - run dotnet watch
- Seeding data and adding a migration
- Reviewing the login page in identity server
    - [SeedData.cs] updates
    - delete [Data/Migrations] folder
    - dotnet ef migrations add "InitialCreate" -o Data/Migrations
- Adding a register page
- Adding client credentials to allow clients to request a token
    - https://docs.duendesoftware.com/identityserver/v7/tokens/password_grant/
    - https://jwt.io/
- Adding a custom profile service to identity server
- Configuring auth on the resource server
    - [AuctionService] install gallery nuget package: Microsoft.AspNetCore.Authentication.JwtBearer @Microsoft
- Configuring the auth endpoints on the resource server


Sec06 - Adding a Gateway service
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- Introduction to Section 6
- Adding the Gateway service
    - [Carsties] dotnet new web -o src/GatewayService
    - [Carsties] dotnet sln add src/GatewayService
    - [GatewayService] clean the project as earlier [GatewayService.csproj, launchSettings.json, appsettings.Development.json]
    - [GatewayService] install gallery nuget package:
        - Yarp.ReverseProxy @Microsoft
        - Microsoft.AspNetCore.Authentication.JwtBearer @Microsoft
- Adding the Reverse Proxy configuration
    - https://microsoft.github.io/reverse-proxy/
- Adding authentication to the Gateway config
- Testing our Gateway service in Postman
- finishing the remaining services before docker
    - Adding the remaining contracts we need
    - Adding the remaining consumers to the Auction Service
    - Adding the remaining consumers in the Search Service
    - Adding a new client to the Identity service configuration


Sec07 - Dockerizing the application
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- Introduction to Section 7
- Dockerizing the Auction Service
- Updating our docker compose file for the Auction Service container
- Dockerising the Search service
- Dockerising the Identity Service
- Debugging a .Net service in a docker container
- Dockerising the Gateway Service
- Testing our docker containers


Sec08 - Adding the client side app
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- Introduction to Section 8
- Creating the NextJS project
    - https://nextjs.org/docs/getting-started/installation
        - [Carsties/fronted] npx create-next-app@latest
        - [web-app] npm run dev
    - VSC Extension: 
        - Tailwind CSS IntelliSense
        - ES7+ React/Redux/React-Native snippets
        - Auto Close Tag
    - learn flex: https://flexboxfroggy.com/
    - react icons: https://react-icons.github.io/react-icons/
- Reviewing and simplifying the NextJS Project
    - Anything that we put inside the app folder is considered a server component
        and it's going to be rendered on the server side and return just the HTML to the client browser.
- Creating a nav bar
- Fetching data from the API
    - done in the server side
- Adding an Auction Card component
- Styling the auction cards
    - [next.config.mjs] allow image url
    - [tailwind.config.ts] enable css plugins
- Adding a countdown timer to the auction card
    - done in the client side by using 'use client'
- Adding loading to the images
- Adding types to the project
- Adding pagination to our list
    - https://flowbite-react.com/docs/getting-started/introduction
- Using server functions in client components
- Adding a set page size option
- Using Zustand for state management
    - https://docs.pmnd.rs/zustand/getting-started/introduction
- Refactoring our code to use the zustand state
- Adding a search bar
- Adding the search functionality 
- Adding a reset to the search function
- Adding the sorting functionality
- Adding the filtering functionality
- Adding a component to display when zero results


Sec09: Client side identity with NextAuth (AuthJS)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- Introduction
- Before we begin
- Installing Next Auth into our client app
    - https://next-auth.js.org/
- Adding the login functionality
    - web-app -> inspect -> Application -> Cookies -> delete all Cookies
    - identity-svc url -> inspect -> Application -> Cookies -> delete all Cookies
- Getting the session details in the client
    - adding env.local file so NextAuth could decrept token
- Populating the session data
    - NextAuth witj typescript - add user name to session.user
        - https://next-auth.js.org/getting-started/typescript#module-augmentation
        - creteing [next-auth.d.ts]
- Populating the User actions dropdown
- Protecting routes
    - https://next-auth.js.org/configuration/nextjs#middleware
- Testing API authentication
- Getting the access token to use to authenticate to our resource server
    - https://next-auth.js.org/tutorials/securing-pages-and-api-routes#using-gettoken


Sec10: CRUD operations in the client app
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- Introduction
- Routing in NextJS
- Getting the auctions won
- Creating an Auction form
    - https://react-hook-form.com/get-started
- Creating a reusable text input
- Creating a reusable date input
- Creating a fetch wrapper
- Adding the create auction server action
    - free images: https://pixabay.com/
- Adding react hot toast to display notifications if something goes wrong
- Adding the auction details page content
- Adding the edit auction page
- Adding the delete auction functionality


Sec11: Creating the bid service
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- Introduction
- Creating the Bid Service
    - [Carsties] dotnet new webapi -o src/BiddingService --use-controllers
    - [Carsties] dotnet sln add src/BiddingService
    - clean the project as earlier
    - add nuget packages from gallery:
        - MongoDB.Entities @Đĵ ΝιΓΞΗΛψΚ
        - Microsoft.AspNetCore.Authentication.JwtBearer @Microsoft
        - MassTransit.RabbitMQ @Chris Patterson
        - AutoMapper.Extensions.Microsoft.DependencyInjection @Jimmy Bogard
    - [BiddingService] verify everything is ok by: dotnet build
    - [BiddingService] run by: dotnet watch
- Adding the models to the Bid Service
- Adding an API Controller for the bids
- Adding the get bids endpoint
- Adding the auction created consumer
    - [BiddingService] dotnet add reference ../../src/Contracts
- Testing the bid functionality in Postman
- Adding the DTOs and Automapper
- Adding a producer for the BidPlaced
- Adding a Background service for the auction finished event
   - We will have a singleton background service that polls the database for auctions that
   have ended but not been marked as finished. For each of these, it will send an event on the service bus.
   This service will run continuously from application startup until shutdown.
- What is gRPC?
    - gRPC is a high-performance, open-source framework developed by Google for remote procedure calls (RPC).
    It enables communication between client and server applications, often running on different machines,
    in a streamlined and efficient manner.
    - When to Use gRPC:
        Microservices Communication: When high performance and low latency are critical, especially for internal service-to-service communication.
        Real-Time Communication: When you need bidirectional streaming or continuous data streams.
        Multi-Language Environments: When your system involves multiple languages and you want to enforce strong typing and schema consistency.
        Mobile and IoT: When you need efficient, low-bandwidth communication.
- Adding gRPC (server)
    - https://learn.microsoft.com/en-us/aspnet/core/grpc/aspnetcore?view=aspnetcore-8.0&tabs=visual-studio-code
    - add nuget package from gallery: [AuctionService] Grpc.AspNetCore @The gRPC Authors
    - Define the Service: Write a .proto file [auctions.proto] with service and message definitions.
        - [AuctionService.csproj] update
        - [appsettings.Development.json] update - custom settings to cummunicate over http insread https
    - Generate Code: Run protoc to generate code.
        - aftet write .proto file [auctions.proto], run dotnet build to generate the code
            you can see the code in [AuctionService/obj/Debug/protos]
    - Implement Server: Implement the server-side logic in the chosen language 
        - [AuctionService/Services/GrpcAuctionService]
    - Implement Client: Use the generated client code to make requests to the server.
        - next in [BiddingService]
- Adding a gRPC client
    - add nuget package from gallery: 
        - [BiddingService] Google.Protobuf @Google Inc.
        - [BiddingService] Grpc.Tools @The gRPC Authors
        - [BiddingService] Grpc.Net.Client @The gRPC Authors
    - as in [AuctionService] but also [BiddingService/Services/GrpcAuctionClient]
    - [BidsController] make grpc request to get the auction
- Updating the Gateway service
- Dockerising the BidService


Sec12: Adding a SignalR service
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- Introduction
- Creating the Notification service
    - [Carsties] dotnet new web -o src/NotificationService
    - [Carsties] dotnet sln add src/NotificationService
    - [NotificationService] dotnet add reference ../../src/Contracts
    - clean the project
    - add packages from nuget gallery:
        - MassTransit.RabbitMQ @Chris Patterson
- Adding a SignalR Hub
- Adding the Consumers
- Adding CORS support to the Gateway
- Dockerising the NotificationService
- Updating the Docker compose file


Sec13: Adding the bids/notifications to the client
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- Introduction
- Refactoring the auctions into a zustand store
- Updating the Auction cards with the current high price
- Getting the bids for an auction
- Creating a bid item
- Creating a bid store
- Creating a bid form
- Updating the error handling
- Adding conditionals to the form and testing
- Adding SignalR to the client app
- Adding the new bid to SignalR
- Adding a toast for an auction created
- Adding a toast for an auction finished event
- Disabling the auction finished form when the auction finishes
- Preventing low bids


Sec14: Publishing the app to production (locally)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- Introduction
- Preparing the client app
    - https://stackoverflow.com/questions/77637651/authoptions-is-not-a-valid-route-export-field
- Creating the Dockerfile for nextjs
    - add "PUBLIC" to env variable so the clinet app side can access it
        NEXT_PUBLIC_NOTIFY_URL=http://gateway-svc/notifications
- Fixing the identity server issues in docker compose
    - define: NEXTAUTH_URL=http://localhost:3000
    - define: NEXTAUTH_URL_INTERNAL=http://web-app:3000
    - add to hosts: "127.0.0.1 identity-svc.carsties.com"
    - define: ID_URL=http://identity-svc.carsties.com
    - docker extension -> identity-svc -> click inspect -> see the dynamic ip address
    - define: extra_hosts in web-app image & define ports 80:80 in identity-svc image
- Giving the Identity Server a static ip address
    - Lists all the networks in docker (the Engine daemon knows about)
        docker network ls
    - define our costom network in [docker-compose.yml] by:
        - adding networks section above
        - adding in each image networks section:
            - default ip by: custom with nothing
            - in identity-svc define the static ip by: ipv4_address
        - in web-app image set extra_hosts to the static ip
    - docker compose down + docker compose up -d + identity-svc -> click inspect -> see the static ip address
    - Fixing [IdentityServer.Config.cs] to use ClientApp url from config file instead of hardcoded url
- Adding an ingress to Docker compose
    - add to hosts: "127.0.0.1 identity-svc.carsties.com app.carsties.com api.carsties.com"
    - docker image: nginxproxy/nginx-proxy - Automated nginx proxy for Docker containers using docker-gen
        - https://hub.docker.com/r/nginxproxy/nginx-proxy
    - add nginx-proxy image
    - remove the ports section from all services (identity, gateway, web-app) that access from external to internal
        and add instead "VIRTUAL_HOST" with the relavat value
    - add to the web-app image "VIRTUAL_PORT"
- Adding SSL to the ingress
    - install mkcert tool - mkcert is a simple tool for making locally-trusted development certificates. It requires no configuration.
        - https://github.com/FiloSottile/mkcert
        - check installation by mkcert -h
    - mkcert -install
    - [Carsties] cd devcerts/
    - [devcerts] mkcert -key-file carsties.com.key -cert-file carsties.com.crt app.carsties.com api.carsties.com identity-svc.carsties.com
    - [docker-compose.yml] - add to nginx-proxy image: 
        - ports: 443:443
        - volumes: ./devcerts:/etc/nginx/certs
- Final app cleanup and resolving SignalR issue
    - [SignalRProvider.tsx] - read the NEXT_PUBLIC_NOTIFY_URL from env.local file instead of docker-compose.yml
        so the solve this check node env.
        - https://github.com/vercel/next.js/discussions/17641
    - [web-app] for performance: npm i sharp


Sec15: Appendix A - Testing
~~~~~~~~~~~~~~~~~~~~~~~~~~~
- Intro to Appendix A - Testing
    - The Testing Pyramid is a concept in software testing that emphasizes the importance of having
        a balanced approach to testing by prioritizing different types of tests in a hierarchical manner.
    - Unit Tests (Base of the Pyramid)
        - Definition: Tests that validate individual components or functions in isolation.
        - Purpose: To ensure that each part of the code works as expected.
        - Characteristics: Fast to execute, high coverage, easy to write and maintain.
        - Quantity: Should have the largest number of tests.
    - Integration Tests (Middle of the Pyramid):
        - Definition: Tests that verify the interactions between different components or systems.
        - Purpose: To ensure that combined parts of the application work together correctly.
        - Characteristics: Slower than unit tests, moderate coverage, more complex to set up and maintain.
        - Quantity: Fewer than unit tests but more than end-to-end tests.
    - End-to-End Tests (Top of the Pyramid):
        - Definition: Tests that validate the complete system, from the user interface to the backend services.
        - Purpose: To ensure that the entire application works as a whole, mimicking real user scenarios.
        - Characteristics: Slowest to execute, lowest coverage, hardest to write and maintain.
        - Quantity: Should have the fewest number of tests.
- The simplest unit test possible
    - [Carsties] dotnet new xunit -o tests/AuctionService.UnitTests
    - [Carsties] dotnet sln add tests/AuctionService.UnitTests
    - [AuctionService.UnitTests] dotnet add reference ../../src/AuctionService
    - [Carsties] dotnet build
- Reviewing the code in the Auction controller and what we are testing
    - cuttrently the [AuctionsController] is not testable beacuse the Dbcontext so...
- Creating an Auction Repository and interface
- Refactoring the Auctions controller to use the repository
- Mocking things
    - add nuget packages from gallery: 
        - Moq @Daniel Cazzulino, kzu
        - AutoFixture @Mark Seemann,AutoFixture
- Unit testing the GET methods
- Unit testing the POST request
    - add [Utils.Helpers] in order to have user claims
- Challenge + Solution - Practicing creating unit tests for the other controller methods
- Integration testing setup
    - [Carsties] dotnet new xunit -o tests/AuctionService.IntegrationTests
    - [Carsties] dotnet sln add tests/AuctionService.IntegrationTests
    - [AuctionService.IntegrationTests] dotnet add reference ../../src/AuctionService
    - add nuget packages from gallery: 
        - Microsoft.AspNetCore.Mvc.Testing @Microsoft
        - Testcontainers.PostgreSql @Andre Hofmeister and contributors
        - WebMotions.Fake.Authentication.JwtBearer @Dominique St-Amand
    - Setting up a reusable test web application factory for integration testing - 
        In the [AuctionService.IntegrationTests] project, create a Fixtures folder.
        Inside, add a class called CustomWebAppFactory which will create a test instance of the web application.
        This allows for the addition of test services and reuse across multiple tests.
        The CustomWebAppFactory inherits from WebApplicationFactory from ASP.NET Core MVC testing,
        enabling the creation of high-value integration tests that provide meaningful feedback and run relatively quickly.
        Next, we'll see how to add test services, such as a fake database, service bus, and authentication,
        to write high-value tests for our application.
- Setting up a Custom web application factory for integration testing
- Adding test data to the DB
- Creating an integration test for the GET method
- Creating an integration test for the POST request
    - adding a fake auth  jwt
- Challenge + solution - Practicing creating integration tests for the other methods
- Testing the Service bus
- Using Collection fixtures to share the DB across test classes
    - We want to make sure our integration tests run as fast as they possibly can do.
        And the way that we achieve that is by not using a different database server for each different test class.
        Now we've got two test classes - AuctionControllerTests & AuctionBusTests.
        Both need access to the database for what they're doing and both of them are going to start up a database
        server. That's what we want to avoid and now we are going to solve that by createing 
        a SharedFixture class that inherits from ICollectionFixture<CustomWebAppFactory>.
    - fix docker files to include tests
- SearchService Integration tests setup
    - [Carsties] dotnet new xunit -o tests/SearchService.IntegrationTests
    - [Carsties] dotnet sln add tests/SearchService.IntegrationTests
    - [SearchService.IntegrationTests] dotnet add reference ../../src/SearchService
    - add nuget packages from gallery: 
        - AutoFixture @Mark Seemann,AutoFixture
        - Microsoft.AspNetCore.Mvc.Testing @Microsoft
        - Mongo2Go
    - fix docker files to include tests


Sec16: Appendix B - Publishing to Kubernetes (locally)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- Intro to Appendix B - Kubernetes
- No 'depends on' in Kubernetes - using Polly to retry instead
    - enable k8s in docker desskop
    - add nuget packages:
        - [AuctionService, BiddingService, IdentityServer, SearchService] Polly @Michael Wolfenden, App vNext
        - update program.ms file [AuctionService, BiddingService, IdentityServer, SearchService] to use retry policy
            on RabbitMQ & db (postgres or mongo).
        - [Carsties] docker compose down + docker compose build
- Adding a GitHub action to push our Identity Server image to Docker hub
    - https://hub.docker.com/
- Deploying our IdentityServer to a Digital Ocean server
    - https://www.digitalocean.com/
    - [digitalocean] create a New Project: CarstiesApp
        - create a cloud server - that's what Identity Server is going to run on
            - It'll allow us to create a server that already has Docker running on it, and we're going to run this
            using Docker compose. Now I know I mentioned that we wouldn't normally use Docker compose for production,
            but I want to think of identity as something that's not microservices application, 
            it's outside of that and we're deploying it so that we can connect to it from our Kubernetes cluster and
            from the client browser without things going pear shaped as they have been.
            And we don't have the workarounds that we do inside Docker compose either available in Kubernetes.
            - [digitalocean/CarstiesApp] - Create -> Droplets (which is just a virtual server effectively)
                - pick location 
                - choose an image -> os marketplace -> Docker 23.06 on Ubunto 22.04
                - CPU options - the cheapest one
                - choose authentication method - password
                - copy the ip => [carsties-identity-ip]
            - We do want this to run over Https and for that we do need a domain name to achieve that.
                - https://www.godaddy.com/en-il
                - [godaddy] 
                    - create a domain
                    - DNS management -> DNS Records -> (Type) A, (Name) carsties-identity, (Value) the ip, (TTL)
        - connect to [carsties-identity-ip]
            - [local terminal]: ssh root@[carsties-identity-ip]
- Configuring the Linux server to host the identity server
    - [carsties-identity-ip/terminal] - mkdir /var/app
    - [carsties-identity-ip/terminal/var/app] - sudo nano docker-compose.yml
        - copy the text from [assets/snippets/deploy/dc-identity.txt] (after replacing all 'CHANGEME' with correct value)
            and paste it on the remote, save by CTRL+X and then press Y.
    - we should just be able to run docker compose and get our services running.
        But we want this to run as a service so that if our Linux server restarts, then it automatically runs this command.
        So we're going to create a service inside Linux to do this:
        - [carsties-identity-ip/terminal] sudo nano /etc/systemd/system/carsties-docker-identity-svc.service
            - copy the text from [assets/snippets/deploy/svc-docker-identity.txt] and paste it on the remote, save by CTRL+X and then press Y.
        - [carsties-identity-ip/terminal] sudo systemctl enable carsties-docker-identity-svc.service
        - [carsties-identity-ip/terminal] - in order to see logs: systemctl restart systemd-journald
        - [carsties-identity-ip/terminal] sudo systemctl status carsties-docker-identity-svc.service
        - [carsties-identity-ip/terminal] sudo systemctl start carsties-docker-identity-svc.service
        - [carsties-identity-ip/terminal] - ubunto firewall to allow ports 80 and 443: 
            - sudo ufw allow 80
            - sudo ufw allow 443
        - [carsties-identity-ip/terminal] the list of the docker containers that running: docker ps
        - [carsties-identity-ip/terminal] see logs - journalctl -u carsties-docker-identity-svc.service
________
- Creating the infrastructure services deployment:
- Creating the first Kubernetes manifest for a deployment
    - VSC Extension - Kubernetes Microsoft
    - createing [infra/k8s/postgress-depl.yml]
    - [k8s] k8s apply -f postgres-depl.yml
- Adding a persistent volume claim
    - createing [infra/k8s/local-pvc.yml]
    - [k8s] k8s apply -f local-pvc.yml
    - [k8s] k8s apply -f postgres-depl.yml
- Adding a load balancer to allow us to connect to the postgres deployment
    - adding load balancer service to [postgres-depl.yml] that we will use this as a kind of window
        into k8s so that we can access this service over this port from local host.
    - [k8s] k8s apply -f postgres-depl.yml
    - [k8s] k8s get services
- Adding a cluster ip our services can use
    - adding  a cluster ip service to [postgres-depl.yml]. Our services are going to need to speak to each other
        inside of k8s. And in order for them to speak to each other, we need to give them a cluster IP address.
    - [k8s] k8s apply -f postgres-depl.yml
- Creating a deployment for RabbitMQ & Mongodb
    - [k8s] k8s apply -f local-pvc.yml (and rabbit and mongo..)
    - http://localhost:15672 - Username & Password: rabbit
    - [k8s] k8s get services/pods/deployments
- Creating the services deployment
    - auction, search, bid, notification, gateway
    - investigate how to use config maps or helm instead of env variables
- Creating the client app deployment
___
- Adding an nginx ingress controller for docker-compose
    - Ingress Controller: The actual implementation that processes the Ingress resource. Examples include NGINX Ingress Controller, Traefik, etc.
    - Why Use Ingress?
        - Simplified External Access: Instead of exposing multiple services individually, an Ingress can route all traffic through a single entry point.
        - Advanced Routing: Ingress allows routing based on domain names, paths, or other rules.
        - TLS Termination: Ingress controllers can handle SSL/TLS termination, offloading that work from your applications.
    - https://github.com/kubernetes/ingress-nginx
    - https://kubernetes.github.io/ingress-nginx/deploy/
    - https://kubernetes.github.io/ingress-nginx/deploy/#quick-start
        - choose If you don't have Helm: paste in terminal: 
        - kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.11.1/deploy/static/provider/cloud/deploy.yaml
        - see the new namespaces ingress-nginx - [terminal] k8s get namespaces
        - see the services in ingress-nginx namespace - [terminal] k8s get services --namespace ingress-nginx
        - create ingress-svc.yml - The file is typically used in Kubernetes to define an Ingress resource.
            An Ingress resource manages external access to the services within a Kubernetes cluster, usually via HTTP and HTTPS.
            The Ingress resource provides a way to route external requests to the appropriate services based on the request's hostname or path.
- Adding SSL to the ingress controller
    - [Carsties/infra/k8s] create devcerts folder
    - [Carsties/infra/k8s/devcerts] mkcert -key-file server.key -cert-file server.crt app.carsties.com api.carsties.com
    - [Carsties/infra/k8s/devcerts] k8s create secret tls carsties-app-tls --key server.key --cert server.crt
    - [Carsties/infra/k8s/devcerts] k8s get secrets
    - [Carsties/infra/k8s/ingress-svc.yml] - add under spec section: ingressClassName and tls sections.
- Fixing Identity Server issues
    - when we try to login there is a (redirect) error to solve this update [IdentityService/HostingExtensions.cs]
    - docker build + pulish the new version of identity-svc image to dockerhub.com
    - connect to the remote identity vm - [local-terminal]: ssh root@[carsties-identity-ip]
    - [carsties-identity-ip/terminal] - cd /var/app
    - [carsties-identity-ip/terminal] - pull the latest iamge of identity-svc from !dockerhub! - docker pull mydockerid/identity-svc
    - [carsties-identity-ip/terminal] - docker compose up -d
    - check the login success
